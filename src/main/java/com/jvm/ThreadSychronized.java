package com.jvm;

/**
 * 介绍jvm是如何保证线程同步的
 * @Author suosong
 * @Date 2018/8/30

    想介绍下synchronized的原理，但是又不知道从何下手，在网上看到一篇老外的文章，介绍了和线程同步相关的几个基础知识点。

    所以想把它翻译一下给大家看看。相信看过这些基础知识之后再看我后面要写的synchronized的原理就会好理解一点了。



    原文地址：How the Java virtual machine performs thread synchronization

    了解Java语言的人都知道，Java代码要想被JVM执行，需要被转换成由字节码组成的class文件。

    本文主要来分析下Java虚拟机是如何在字节码层面上执行线程同步的。

    线程和共享数据

    Java编程语言的优点之一是它在语言层面上对多线程的支持。这种支持大部分集中在协调多个线程对共享数据的访问上。

    JVM的内存结构主要包含以下几个重要的区域：栈、堆、方法区等。

    在Java虚拟中，每个线程独享一块栈内存，其中包括局部变量、线程调用的每个方法的参数和返回值。

    其他线程无法读取到该栈内存块中的数据。栈中的数据仅限于基本类型和对象引用。所以，在JVM中，栈上是无法保存真实的对象的，只能保存对象的引用。

    真正的对象要保存在堆中。

    在JVM中，堆内存是所有线程共享的。堆中只包含对象，没有其他东西。所以，堆上也无法保存基本类型和对象引用。

    堆和栈分工明确。但是，对象的引用其实也是对象的一部分。这里值得一提的是，数组是保存在堆上面的，即使是基本类型的数据，也是保存在堆中的。

    因为在Java中，数组是对象。

    除了栈和堆，还有一部分数据可能保存在JVM中的方法区中，比如类的静态变量。

    方法区和栈类似，其中只包含基本类型和对象应用。和栈不同的是，方法区中的静态变量可以被所有线程访问到。

    对象和类的锁

    如前文提到，JVM中有两块内存区域可以被所有线程共享：

    堆，上面存放着所有对象

    方法区，上面存放着静态变量

    那么，如果有多个线程想要同时访问同一个对象或者静态变量，就需要被管控，否则可能出现不可预期的结果。

    为了协调多个线程之间的共享数据访问，虚拟机给每个对象和类都分配了一个锁。这个锁就像一个特权，在同一时刻，只有一个线程可以“拥有”这个类或者对象。

    如果一个线程想要获得某个类或者对象的锁，需要询问虚拟机。

    当一个线程向虚拟机申请某个类或者对象的锁之后，也许很快或者也许很慢虚拟机可以把锁分配给这个线程，同时这个线程也许永远也无法获得锁。

    当线程不再需要锁的时候，他再把锁还给虚拟机。这时虚拟机就可以再把锁分配给其他申请锁的线程。

    类锁其实通过对象锁实现的。因为当虚拟机加载一个类的时候，会为这个类实例化一个 java.lang.Class 对象，当你锁住一个类的时候，其实锁住的是其对应的Class 对象。

    监视器（Monitors）

    监视器和锁同时被JVM使用（我理解作者的意思应该是想说锁其实是通过监视器实现的。），监视器主要功能是监控一段代码，确保在同一时间只有一个线程在执行。

    每个监视器都与一个对象相关联。当线程执行到监视器监视下的代码块中的第一条指令时，线程必须获取对被引用对象的锁定。在线程获取锁之前，他是无法执行这段代码的，一旦获得锁，线程便可以进入“被保护”的代码开始执行。

    当线程离开代码块的时候，无论如何离开，都会释放所关联对象的锁。

    多次加锁

    同一个线程可以对同一个对象进行多次加锁。每个对象维护着一个记录着被锁次数的计数器。

    未被锁定的对象的该计数器为0，当一个线程获得锁后，该计数器自增变为 1 ，当同一个线程再次获得该对象的锁的时候，计数器再次自增。

    当同一个线程释放锁的时候，计数器再自减。当计数器为0的时候。锁将被释放，其他线程便可以获得锁。

    同步
    在Java中，当有多个线程都必须要对同一个共享数据进行访问时，有一种协调方式叫做同步。

    Java语言提供了两种内置方式来使线程同步的访问数据：同步代码块和同步方法。

    这篇文章中后面还介绍了同步代码块和同步方法，以及简单的介绍了下实现方式。这里就不做翻译了，因为我觉得他介绍的太简单了。我后面专门写篇文章详细介绍。

 */
public class ThreadSychronized {
}
